<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL 1.0 Working Shader</title>
  <style>html,body{margin:0;height:100%;overflow:hidden;background:black;}canvas{width:100%;height:100%;display:block;}</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script id="vertexShader" type="x-shader/x-vertex">
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;

float myTanh(float x) {
    return (exp(2.0 * x) - 1.0) / (exp(2.0 * x) + 1.0);
}

void main() {
    float e = 0.001;
    float R = 1.0;
    float o = 0.0;
    vec3 q = vec3(0.0);
    vec3 p;
    vec3 d = vec3(((gl_FragCoord.xy * 2.0 - u_resolution) / u_resolution.y) * 1.5 + vec2(0.0, 1.0), 1.0);

    q.zy -= 1.0;

    for (int i = 0; i < 77; i++) {
        o += 0.011 - exp(-e * 2000.0) * 0.016;
        p = q + d * e * R * 0.2;

        R = length(p);
        R = max(R, 0.0001);
        p = vec3(log2(R) - u_time * 0.4, exp(-p.z / R), atan(p.x, p.y) + u_time * 0.2);

        e = p.y - 1.0;

        float inner_s = 1.0;
        for (int j = 0; j < 10; j++) {  // fixed 10 iterations instead of while loop
            e += abs(dot(sin(p.xxz * inner_s), cos(p * inner_s))) / inner_s * 0.17;
            inner_s += inner_s;
        }

        q += d * e * R * 0.2;
    }

    o = myTanh(o);
    gl_FragColor = vec4(vec3(o), 1.0);
}
</script>

<script>
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link failed:', gl.getProgramInfoLog(program));
        return null;
    }
    return program;
}

function main() {
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
        alert("WebGL not supported");
        return;
    }

    const vsSource = document.getElementById("vertexShader").text;
    const fsSource = document.getElementById("fragmentShader").text;

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    if (!vertexShader || !fragmentShader) return;

    const program = createProgram(gl, vertexShader, fragmentShader);
    if (!program) return;
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    const timeLocation = gl.getUniformLocation(program, "u_time");

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1,  -1,  1,
        -1,  1,  1, -1,   1,  1,
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener('resize', resize);
    resize();

    function render(time) {
        time *= 0.001;
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(timeLocation, time);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
}
main();
</script>
</body>
</html>
